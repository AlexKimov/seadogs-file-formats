//------------------------------------------------
//--- 010 Editor v8.0.1 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

local uint v = true; // ??

struct {
  struct {
    FLOAT X;
    FLOAT Y;
    FLOAT Z;
  } OBJECT_ORIGIN;
  struct {
    FLOAT X;
    FLOAT Y;
    FLOAT Z;
  } OBJECT_SCALE;
  UINT TextureCount;
  UINT TPCount;
  UINT Unknown;
  UINT SectionOffset;
  FLOAT radius;
} FILE_HEADER <name="File Header">;

typedef struct {
  UBYTE Length;
  char FileName[Length];
} TEXTURE_FILE <name=texFileName>;

string texFileName(TEXTURE_FILE &file) {
  return file.FileName;
}

typedef struct (uint size) {
  TEXTURE_FILE array[size] <optimize=false>;
} FILE_LIST;

FILE_LIST Textures(FILE_HEADER.TextureCount) <name="Textures List">;

typedef struct {
  UINT Unknown;
  UINT Unknown;
  UINT Unknown;
  UINT Unknown;
  UINT Unknown;
  UINT Unknown;
  UINT Unknown;
  FLOAT Unknown;
  UINT Unknown;
  UINT Unknown;
  UINT Unknown;
  FLOAT Unknown;
  UINT Unknown;
  UINT Unknown;
  UINT Unknown;
} TEXTURE_PROPERTIES <>;

TEXTURE_PROPERTIES TexProperties[FILE_HEADER.TPCount];

UINT MeshCount;
UINT Count;



typedef struct {
  struct {
    struct {
      FLOAT X;
      FLOAT Y;
      FLOAT Z;
    } MESH_ORIGIN;
    FLOAT D;
    FLOAT Radius;
    UINT TextureIndex;
    UINT VertexCount <name="Number of vertexes">;
    UINT FaceCount <name="Number of faces">;
    UINT Unknown;
    UINT AnimationKeyCount;
    char MeshName[4];
  } HEADER;

  struct {
     HFLOAT X;     
     HFLOAT Y;     
     HFLOAT Z;
     UINT16 U;     
     UINT16 V;
     if (v) 
       UBYTE Color[3];
     else
       UINT16 G;     
  } VERTEX[HEADER.VertexCount];

  struct {
    if (HEADER.VertexCount <= 256) {
      UBYTE I1;
      UBYTE I2;
      UBYTE I3;
    } else {
      BYTE A;
      UBYTE I1;
      BYTE B;
      UBYTE I2;
      BYTE C;
      UBYTE I3;
    };
  } FACE_INDEXES[HEADER.FaceCount] <name="Face Indexes">;

  struct {
    struct {
      FLOAT X;
      FLOAT Y;
      FLOAT Z;
    } POSITION;
    struct {
      FLOAT X;
      FLOAT Y;
      FLOAT Z;
    } ROTATION;
    FLOAT Time; //
  } ANIMATIONS[HEADER.AnimationKeyCount];

} MESH <optimize=false, name=meshName>;

string meshName(MESH &mesh) {
  return mesh.HEADER.MeshName;
}

typedef struct (uint size) {
  MESH array[size];
} MESH_ARRAY;

MESH_ARRAY Objects(MeshCount) <name="Meshes">;

if (FILE_HEADER.SectionOffset > 0) {

struct {
  UINT A;
  UINT B;
  UINT C;
  UINT D;
  UINT Size;
  UINT Count;
  UINT16 T1;
  UINT16 T2;
  
} HEADER;

};

